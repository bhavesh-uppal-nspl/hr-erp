import React, { useState, useCallback, useRef, useEffect } from 'react';
import { Box, Paper, TextField, InputAdornment, useTheme, Menu, MenuItem } from '@mui/material';
import { Search } from 'lucide-react';
import TableRowsIcon from '@mui/icons-material/TableRows';
import ViewModuleIcon from '@mui/icons-material/ViewModule';
import { ToggleButton, ToggleButtonGroup, Button } from '@mui/material';
import { Filter, Download, Printer } from 'lucide-react';
import * as XLSX from 'xlsx';
import { useSearchParams, useNavigate } from 'react-router-dom';
import { operatorRequiresValue } from '../filters/operators';

/**
 * Toolbar Component
 * Displays search input and action buttons (view toggle, filter, export, print, etc.)
 */
function Toolbar({
  searchQuery,
  setSearchQuery,
  view,
  setView,
  colors,
  isSmallScreen,
  // Export function dependencies
  columns,
  filteredData,
  getNestedValue,
  formatLabel,
  userData,
  tableName,
  recordKey,
  recordLabel,
  // Search dependencies
  updateURL,
  setCurrentPage,
  // Filter dependencies
  loadedBackendConfig,
  convertToFilterBuilderFormat,
  setPendingFilters,
  setPendingFilterBuilderFilters,
  setLockedFilters,
  setShowFilters,
  handleFilterDialogOpen: handleFilterDialogOpenProp,
  // Print dependencies
  data,
}) {
  const theme = useTheme();
  const navigate = useNavigate();
  const [searchParams] = useSearchParams();
  const [exportMenuAnchorEl, setExportMenuAnchorEl] = useState(null);
  const searchDebounceRef = useRef(null);

  // Export to Excel
  const exportToExcel = useCallback(() => {
    const visibleColumns = columns.filter((col) => col.visible);
    const organizationName =
      userData?.organization?.organization_name || "KS Travel Report";
    const generatedBy = userData?.user?.name || "System User";
    const generatedDate = new Date().toLocaleDateString("en-US", {
      month: "2-digit",
      day: "2-digit",
      year: "2-digit",
    });

    // Prepare main data
    const dataForExcel = filteredData.map((row) => {
      const newRow = {};
      visibleColumns.forEach((col) => {
        newRow[col.label] = getNestedValue(row, col.key);
      });
      return newRow;
    });

    // Create a header row (above data)
    const headerRows = [
      { A: organizationName },
      { A: tableName },
      { A: `Generated by: ${generatedBy}` },
      { A: `Generated on: ${generatedDate}` },
      {}, // blank row for spacing
    ];

    // Convert headerRows + dataForExcel to sheet
    const ws = XLSX.utils.json_to_sheet([], { skipHeader: true });
    XLSX.utils.sheet_add_json(ws, headerRows, {
      skipHeader: true,
      origin: "A1",
    });
    XLSX.utils.sheet_add_json(ws, dataForExcel, { origin: -1 });

    // Adjust column widths
    const columnWidths = visibleColumns.map((col) => {
      const headerText = col.label || "";
      const maxDataLength = filteredData.reduce((max, row) => {
        const cellValue = String(getNestedValue(row, col.key) || "");
        return Math.max(max, cellValue.length);
      }, 0);
      return { wch: Math.max(headerText.length, maxDataLength) + 2 };
    });

    ws["!cols"] = columnWidths;

    // Optional: bold the top rows (header info)
    const boldRows = [1, 2]; // rows A1, A2 (organization + table)
    boldRows.forEach((r) => {
      const cellAddress = `A${r}`;
      if (ws[cellAddress]) {
        ws[cellAddress].s = {
          font: { bold: true, sz: 14 },
        };
      }
    });

    // Create workbook and export
    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, "Report");

    const excelBuffer = XLSX.write(wb, { bookType: "xlsx", type: "array" });
    const blob = new Blob([excelBuffer], {
      type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    });
    const url = URL.createObjectURL(blob);

    const a = document.createElement("a");
    a.href = url;
    a.download = `${tableName}_${generatedDate}.xlsx`;
    a.click();

    URL.revokeObjectURL(url);
    setExportMenuAnchorEl(null);
  }, [columns, filteredData, getNestedValue, userData, tableName]);

  // Export to CSV
  const exportToCSV = useCallback(() => {
    const visibleColumns = columns.filter((col) => col.visible);
    const organizationName =
      userData?.organization?.organization_name ||
      "Nest Software Private Limited";
    const generatedBy = userData?.user_name || "System User";
    const generatedOn = new Date().toLocaleDateString();

    // Add metadata header
    const metadata = [
      [`${organizationName}`],
      [`${tableName}`],
      [`Generated By: ${generatedBy}`],
      [`Generated On: ${generatedOn}`],
      [], // blank line
    ];

    // Add column headers
    const headers = [visibleColumns.map((col) => col.label)];

    // Add data rows
    const rows = filteredData.map((row) =>
      visibleColumns.map((col) =>
        String(getNestedValue(row, col.key) ?? "").replace(/"/g, '""')
      )
    );

    // Combine all parts
    const allData = [...metadata, ...headers, ...rows];

    // Convert to CSV format
    const csvContent = allData
      .map((row) => row.map((v) => `"${v}"`).join(","))
      .join("\n");

    // Create blob and trigger download
    const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `${tableName}.csv`;
    a.click();
    URL.revokeObjectURL(url);
    setExportMenuAnchorEl(null);
  }, [columns, filteredData, getNestedValue, tableName, userData]);

  // Export to HTML
  const exportToHTML = useCallback(() => {
    const visibleColumns = columns.filter((col) => col.visible);
    const organizationName =
      userData?.organization?.organization_name || "KS Travel Report";
    const generatedDate = new Date().toLocaleDateString();

    // Build records HTML
    const recordsHTML = filteredData
      .map(
        (row) =>
          `<div style="margin-bottom: 30px; page-break-inside: avoid;">
          <h3 style="color: #333; margin-bottom: 15px; font-size: 16px; font-weight: bold;">${recordLabel} ${row[recordKey]}</h3>
          <table style="border-collapse: collapse; width: 100%; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
            <tbody>
              ${visibleColumns
                .map(
                  (col) =>
                    `<tr>
                      <td style="border: 1px solid #ddd; padding: 12px; background-color: #f5f5f5; font-weight: bold; width: 30%;">${formatLabel(
                        col.label
                      )}</td>
                      <td style="border: 1px solid #ddd; padding: 12px; width: 70%;">${String(
                        getNestedValue(row, col.key) || ""
                      )}</td>
                    </tr>`
                )
                .join("")}
            </tbody>
          </table>
        </div>`
      )
      .join("");

    const htmlContent = `<!DOCTYPE html>
<html>
<head>
  <title>${organizationName}</title>
  <style>
    body { 
      font-family: 'Roboto', 'Helvetica', 'Arial', sans-serif; 
      margin: 20px; 
    }
    h1 { 
      color: #333333; 
      margin-bottom: 5px;
      font-size: 24px;
    }
    h2 { 
      color: #333333; 
      margin-bottom: 15px;
      font-size: 18px;
      font-weight: normal;
    }
    .info { 
      color: #666666; 
      margin-bottom: 30px; 
      font-size: 14px; 
    }
    .info-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 5px;
    }
  </style>
</head>
<body>
  <h1>${organizationName}</h1>
  <h2>${tableName}</h2>
  <div class="info">
    <div class="info-row">
      <span>Generated on: ${generatedDate}</span>
      <span>Total Records: ${filteredData.length}</span>
    </div>
  </div>
  ${recordsHTML}
</body>
</html>`;

    const blob = new Blob([htmlContent], { type: "text/html" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `${tableName}.html`;
    a.click();
    URL.revokeObjectURL(url);
    setExportMenuAnchorEl(null);
  }, [columns, filteredData, getNestedValue, formatLabel, userData, recordKey, recordLabel, tableName]);

  // Export to PDF
  const exportToPDF = useCallback(async () => {
    try {
      const jsPDFModule = await import("jspdf");
      const jsPDF = jsPDFModule.default;
      const doc = new jsPDF();
      const visibleColumns = columns.filter((col) => col.visible);

      if (visibleColumns.length === 0) {
        alert("No visible columns to export. Please manage columns first.");
        setExportMenuAnchorEl(null);
        return;
      }

      if (filteredData.length === 0) {
        alert("No data to export after applying filters.");
        setExportMenuAnchorEl(null);
        return;
      }

      const pageWidth = doc.internal.pageSize.width;
      const pageHeight = doc.internal.pageSize.height;
      const margin = 14;
      const usableWidth = pageWidth - 2 * margin;
      const cellPadding = 2;
      const lineHeight = doc.getLineHeight() / doc.internal.scaleFactor;
      const minCellHeight = 8;
      let currentY = 40;

      const keyColumnWidth = (() => {
        let maxWidth = 0;
        visibleColumns.forEach((col) => {
          const cleanedLabel = col.label.replace(/_/g, " ");
          maxWidth = Math.max(maxWidth, doc.getTextWidth(cleanedLabel));
        });
        return Math.min(maxWidth + cellPadding * 2, usableWidth * 0.3);
      })();

      const valueColumnWidth = usableWidth - keyColumnWidth;

      // Header
      doc.setFontSize(18);
      doc.setFont(undefined, "bold");
      const organizationName =
        userData?.organization?.organization_name || "KS Travel Report";
      doc.text(organizationName, margin, 20);

      doc.setFontSize(14);
      doc.setFont(undefined, "normal");
      doc.text(tableName, margin, 30);

      doc.setFontSize(10);
      doc.text(
        `Generated on: ${new Date().toLocaleDateString()}`,
        margin,
        currentY
      );
      doc.text(
        `Total Records: ${filteredData.length}`,
        pageWidth - margin - 50,
        currentY
      );
      currentY += 15;

      // Data Rows
      filteredData.forEach((dataRow, recordIndex) => {
        const recordTitleHeight = 14;
        const spacingBeforeTitle = 15;
        const spacingAfterTitle = 10;
        const spacingAfterTable = 15;

        let recordBlockContentHeight = 0;

        visibleColumns.forEach((col) => {
          const value = String(getNestedValue(dataRow, col.key) || "");
          const cleanedValue = value.replace(/_/g, " ");
          const valueLines = doc.splitTextToSize(
            cleanedValue,
            valueColumnWidth - cellPadding * 2
          );
          const rowHeight = Math.max(
            minCellHeight,
            valueLines.length * lineHeight + cellPadding * 2
          );
          recordBlockContentHeight += rowHeight;
        });

        const totalRecordBlockHeight =
          spacingBeforeTitle +
          recordTitleHeight +
          spacingAfterTitle +
          recordBlockContentHeight +
          spacingAfterTable;

        if (
          recordIndex > 0 &&
          currentY + totalRecordBlockHeight > pageHeight - margin
        ) {
          doc.addPage();
          currentY = margin;
        } else if (
          recordIndex === 0 &&
          currentY + totalRecordBlockHeight > pageHeight - margin &&
          currentY > margin
        ) {
          doc.addPage();
          currentY = margin;
        }

        if (currentY > margin) currentY += spacingBeforeTitle;

        // Record title
        doc.setFontSize(14);
        doc.setFont(undefined, "bold");
        const recordId = dataRow[recordKey] || "N/A";
        const recordTitle = `${recordLabel} ${recordId}`;
        doc.text(recordTitle, margin, currentY);
        currentY += recordTitleHeight + spacingAfterTitle;

        doc.setFontSize(10);
        doc.setFont(undefined, "normal");
        doc.setDrawColor(0);

        visibleColumns.forEach((col) => {
          const cleanedLabel = col.label
            .replace(/_/g, " ")
            .replace(/([A-Z])/g, " $1")
            .replace(/\s+/g, " ")
            .trim();
          const formattedLabel =
            cleanedLabel.charAt(0).toUpperCase() + cleanedLabel.slice(1);

          const value = String(getNestedValue(dataRow, col.key) || "")
            .replace(/_/g, " ")
            .trim();

          const valueLines = doc.splitTextToSize(
            value,
            valueColumnWidth - cellPadding * 2
          );
          const rowHeight = Math.max(
            minCellHeight,
            valueLines.length * lineHeight + cellPadding * 2
          );

          // Draw key cell
          doc.rect(margin, currentY, keyColumnWidth, rowHeight, "S");
          const labelLines = doc.splitTextToSize(
            formattedLabel,
            keyColumnWidth - cellPadding * 2
          );
          const totalLabelHeight = labelLines.length * lineHeight;
          const labelYOffset = (rowHeight - totalLabelHeight) / 2;
          labelLines.forEach((line, lineIndex) => {
            doc.text(
              line,
              margin + cellPadding,
              currentY + labelYOffset + lineHeight * lineIndex,
              { baseline: "top", align: "left" }
            );
          });

          // Draw value cell
          doc.rect(
            margin + keyColumnWidth,
            currentY,
            valueColumnWidth,
            rowHeight,
            "S"
          );
          const totalValueHeight = valueLines.length * lineHeight;
          const valueYOffset = (rowHeight - totalValueHeight) / 2;
          valueLines.forEach((line, lineIndex) => {
            doc.text(
              line,
              margin + keyColumnWidth + cellPadding,
              currentY + valueYOffset + lineHeight * lineIndex,
              { baseline: "top", align: "left" }
            );
          });

          currentY += rowHeight;
        });

        currentY += spacingAfterTable;
      });

      // Footer
      const pageCount = doc.internal.getNumberOfPages();
      for (let i = 1; i <= pageCount; i++) {
        doc.setPage(i);
        doc.setFontSize(8);
        doc.text(
          `Page ${i} of ${pageCount}`,
          pageWidth - margin - 30,
          pageHeight - 10
        );
        doc.text(
          `${filteredData.length} records exported`,
          margin,
          pageHeight - 10
        );
      }

      const fileName = `${tableName}.pdf`;
      doc.save(fileName);
      setExportMenuAnchorEl(null);
    } catch (error) {
      console.error("PDF export failed:", error);
      alert("PDF export failed. Please try again.");
    }
  }, [
    columns,
    filteredData,
    getNestedValue,
    formatLabel,
    userData,
    recordKey,
    recordLabel,
    tableName,
  ]);

  // Handle search change with debounce
  const handleSearchChange = useCallback((e) => {
    const value = e.target.value;
    setSearchQuery(value);

    if (searchDebounceRef.current) {
      clearTimeout(searchDebounceRef.current);
    }

    searchDebounceRef.current = setTimeout(() => {
      updateURL({ searchQuery: value, currentPage: 1 });
      setCurrentPage(1);
    }, 500);
  }, [setSearchQuery, updateURL, setCurrentPage]);

  // Handle view change
  const handleViewChange = useCallback((newView) => {
    setView(newView);
  }, [setView]);

  // Handle filter dialog open
  // Use prop handler if provided, otherwise use internal implementation
  const handleFilterDialogOpenInternal = useCallback(() => {
    let initialFilters = {};
    let readOnlyFilters = {};

    // Case 1: If backend config has saved filters
    if (loadedBackendConfig?.filters) {
      initialFilters = loadedBackendConfig.filters;
    } else {
      // Case 2: Parse filters from URL (e.g. filter_Employment_Type=employee)
      // Skip operator params (filter_{field}_operator) - they will be read by convertToFilterBuilderFormat
      searchParams.forEach((value, key) => {
        if (key.startsWith("filter_") && !key.endsWith("_operator")) {
          const filterKey = key.replace("filter_", "");
          // Check if operator doesn't require value
          const operatorKey = `filter_${filterKey}_operator`;
          const operator = searchParams.get(operatorKey);
          const requiresValue = operator ? operatorRequiresValue(operator) : true;
          
          // Include filter if value exists OR if operator doesn't require value
          if (value || !requiresValue) {
            initialFilters[filterKey] = value || '';
            readOnlyFilters[filterKey] = true; // mark this filter as read-only
          }
        }
      });
    }

    // Convert simple filters to FilterBuilder format (will read operators from searchParams)
    const filterBuilderFilters = convertToFilterBuilderFormat(initialFilters);
    
    setPendingFilters(initialFilters);
    setPendingFilterBuilderFilters(filterBuilderFilters);
    setLockedFilters(readOnlyFilters);
    setShowFilters(true);
  }, [loadedBackendConfig, searchParams, convertToFilterBuilderFormat, setPendingFilters, setPendingFilterBuilderFilters, setLockedFilters, setShowFilters]);

  // Use prop handler if provided, otherwise use internal one
  const handleFilterDialogOpen = handleFilterDialogOpenProp || handleFilterDialogOpenInternal;

  // Handle print
  const handlePrint = useCallback(() => {
    const printStyles = document.createElement("style");
    printStyles.id = "table-print-styles";
    printStyles.innerHTML = `
    @media print {
      body * { visibility: hidden; }
      .custom-print-container, .custom-print-container * { visibility: visible; }
      .custom-print-container {
        position: absolute;
        left: 0; top: 0;
        width: 100%;
        font-family: Arial, sans-serif;
        font-size: 12px;
        line-height: 1.4;
        color: #000;
        background: white;
        padding: 20px;
        box-sizing: border-box;
      }
      @page {
        size: A4;
        margin: 15mm;
      }
      .print-header {
        text-align: left;
        margin-bottom: 30px;
      }
      .print-title {
        font-size: 18px;
        font-weight: bold;
        margin-bottom: 5px;
      }
      .print-subtitle {
        font-size: 14px;
        margin-bottom: 15px;
      }
      .print-meta {
        display: flex;
        justify-content: space-between;
        font-size: 11px;
        margin-bottom: 20px;
      }
      .record-section {
        margin-bottom: 30px;
        page-break-inside: avoid;
      }
      .record-title {
        font-size: 14px;
        font-weight: bold;
        margin-bottom: 15px;
      }
      .record-table {
        width: 100%;
        border-collapse: collapse;
        border: 2px solid #000;
        margin-bottom: 20px;
      }
      .record-table td {
        border: 1px solid #000;
        padding: 8px 12px;
        vertical-align: top;
      }
      .record-table .field-name {
        background-color: #f0f0f0;
        font-weight: bold;
        width: 30%;
        -webkit-print-color-adjust: exact;
        color-adjust: exact;
      }
      .record-table .field-value {
        width: 70%;
      }
      .print-footer {
        position: fixed;
        bottom: 10mm;
        left: 0;
        right: 0;
        text-align: center;
        font-size: 10px;
      }
    }
  `;
    document.head.appendChild(printStyles);

    const currentDate = new Date().toLocaleDateString("en-US", {
      month: "2-digit",
      day: "2-digit",
      year: "2-digit",
    });

    const tableData = data || [];
    const totalRecords = tableData.length;

    const printContent = document.createElement("div");
    printContent.className = "custom-print-container";

    const header = document.createElement("div");
    header.className = "print-header";
    const organizationName =
      userData?.organization?.organization_name || "KS Travel";
    header.innerHTML = `
    <div class="print-title">${organizationName}</div>
    <div class="print-subtitle">${tableName}</div>
    <div class="print-meta">
      <span>Generated on: ${currentDate}</span>
      <span>Total Records: ${totalRecords}</span>
    </div>
  `;
    printContent.appendChild(header);

    // Visible columns
    const visibleColumns = columns
      .filter((col) => col.visible)
      .map((col) => col.key);

    // Generate record sections
    tableData.forEach((row) => {
      const recordSection = document.createElement("div");
      recordSection.className = "record-section";

      const recordId = row[recordKey] || "N/A";
      const recordTitle = document.createElement("div");
      recordTitle.className = "record-title";
      recordTitle.textContent = `${recordLabel} ${recordId}`;
      recordSection.appendChild(recordTitle);

      const recordTable = document.createElement("table");
      recordTable.className = "record-table";

      visibleColumns.forEach((key) => {
        if (key.startsWith("_")) return;
        const value = row[key];

        const tableRow = document.createElement("tr");
        const fieldNameCell = document.createElement("td");
        fieldNameCell.className = "field-name";

        // Clean up key name for print
        const cleanedKey = key
          .replace(/_/g, " ") // underscores to spaces
          .replace(/([A-Z])/g, " $1")
          .replace(/\s+/g, " ")
          .trim();

        fieldNameCell.textContent =
          cleanedKey.charAt(0).toUpperCase() + cleanedKey.slice(1);

        const fieldValueCell = document.createElement("td");
        fieldValueCell.className = "field-value";

        // Clean up underscores in values as well
        fieldValueCell.textContent = (value || "")
          .toString()
          .replace(/_/g, " ");

        tableRow.appendChild(fieldNameCell);
        tableRow.appendChild(fieldValueCell);
        recordTable.appendChild(tableRow);
      });

      recordSection.appendChild(recordTable);
      printContent.appendChild(recordSection);
    });

    const footer = document.createElement("div");
    footer.className = "print-footer";
    footer.innerHTML = `${totalRecords} records exported<span style="float: right;">Page 1 of 2</span>`;
    printContent.appendChild(footer);

    document.body.appendChild(printContent);

    window.print();

    setTimeout(() => {
      document.body.removeChild(printContent);
      const printStylesElement = document.getElementById("table-print-styles");
      if (printStylesElement) {
        printStylesElement.remove();
      }
    }, 1000);
  }, [data, userData, columns, tableName, recordKey, recordLabel]);

  // Handle personalize layout navigation
  const handlePersonalizeLayoutClick = useCallback(() => {
    navigate("personalize-view");
  }, [navigate]);

  // Handle export menu open
  const handleExportClick = useCallback((event) => {
    setExportMenuAnchorEl(event.currentTarget);
  }, []);

  // Cleanup search debounce on unmount
  useEffect(() => {
    return () => {
      if (searchDebounceRef.current) {
        clearTimeout(searchDebounceRef.current);
      }
    };
  }, []);

  return (
    <>
    <Paper
      elevation={1}
      sx={{
        mb: 3,
        p: isSmallScreen ? 1 : 2,
        display: 'flex',
        flexDirection: isSmallScreen ? 'column' : 'row',
        flexWrap: isSmallScreen ? 'nowrap' : 'wrap',
        gap: isSmallScreen ? 1 : 0.5,
        alignItems: isSmallScreen ? 'stretch' : 'center',
        justifyContent: isSmallScreen ? 'flex-start' : 'space-between',
        backgroundColor: colors.surface,
        width: '100%',
        minWidth: 0,
      }}
    >
      <TextField
        size="small"
        placeholder="Search..."
        value={searchQuery}
        onChange={handleSearchChange}
        sx={{
          minWidth: '300px',
          maxWidth: isSmallScreen ? '100%' : '400px',
          width: isSmallScreen ? '100%' : 'auto',
          mb: isSmallScreen ? 1 : 0,
          '& .MuiOutlinedInput-root': {
            backgroundColor: theme.palette.background.paper,
          },
        }}
        InputProps={{
          startAdornment: (
            <InputAdornment position="start">
              <Search size={18} color={colors.grey[500]} />
            </InputAdornment>
          ),
        }}
      />
      <Box
        sx={{
          display: 'flex',
          flexDirection: isSmallScreen ? 'row' : 'row',
          flexWrap: isSmallScreen ? 'wrap' : 'nowrap',
          gap: isSmallScreen ? 1 : 0.5,
          width: isSmallScreen ? '100%' : 'auto',
          justifyContent: isSmallScreen ? 'flex-start' : 'flex-end',
          alignItems: 'center',
        }}
      >
        {/* View Toggle */}
        <Box display="flex" gap={1} alignItems="center">
          <ToggleButtonGroup value={view} exclusive size="small">
            <ToggleButton value="table" onClick={() => handleViewChange('table')}>
              <TableRowsIcon />
            </ToggleButton>
            <ToggleButton value="card" onClick={() => handleViewChange('card')}>
              <ViewModuleIcon />
            </ToggleButton>
          </ToggleButtonGroup>
        </Box>

        {/* Filter Button */}
        <Button
          variant="text"
          title="Filters"
          sx={{
            backgroundColor: 'transparent',
            color: theme.palette.text.primary,
            '&:hover': {
              backgroundColor: theme.palette.action.hover,
            },
            borderRadius: '50%',
            minWidth: '48px',
            width: '48px',
            height: '48px',
            position: 'relative',
          }}
          onClick={handleFilterDialogOpen}
        >
          <Filter size={20} />
        </Button>

        {/* Export Button */}
        <Box sx={{ position: 'relative' }}>
          <Button
            variant="text"
            title="Export Data"
            sx={{
              backgroundColor: 'transparent',
              color: theme.palette.text.primary,
              '&:hover': {
                backgroundColor: theme.palette.action.hover,
              },
              borderRadius: '50%',
              minWidth: '48px',
              width: '48px',
              height: '48px',
            }}
            onClick={handleExportClick}
          >
            <Download size={20} />
          </Button>
        </Box>

        {/* Print Button */}
        <Button
          variant="text"
          title="Print Table"
          sx={{
            backgroundColor: 'transparent',
            color: theme.palette.text.primary,
            '&:hover': {
              backgroundColor: theme.palette.action.hover,
            },
            borderRadius: '50%',
            minWidth: '48px',
            width: '48px',
            height: '48px',
          }}
          onClick={handlePrint}
        >
          <Printer size={20} />
        </Button>

        {/* Personalize Layout Button */}
        <Button
          title="Personalize View"
          sx={{
            borderColor: theme.palette.text.primary,
            color: theme.palette.text.primary,
            '&:hover': {
              backgroundColor: theme.palette.hover,
            },
            fontSize: '1rem',
            fontWeight: 'semi-bold',
            textTransform: 'capitalize',
            position: 'relative',
          }}
          onClick={handlePersonalizeLayoutClick}
        >
          Personalize View
        </Button>
      </Box>
    </Paper>

    {/* Export Menu */}
    <Menu
      anchorEl={exportMenuAnchorEl}
      open={Boolean(exportMenuAnchorEl)}
      onClose={() => setExportMenuAnchorEl(null)}
    >
      <MenuItem onClick={exportToExcel}>Export to XLS</MenuItem>
      <MenuItem onClick={exportToPDF}>Export to PDF</MenuItem>
      <MenuItem onClick={exportToHTML}>Export to HTML</MenuItem>
      <MenuItem onClick={exportToCSV}>Export to CSV</MenuItem>
    </Menu>
    </>
  );
}

export default Toolbar;

